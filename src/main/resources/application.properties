# ==================================================
#  CONFIGURACION PRINCIPAL DE LA APLICACION
# ==================================================
spring.application.name=backend
# Render inyectará su propia variable PORT (ej. 10000).
# Localmente, usará el valor por defecto 8080.
server.port=${PORT:8080}

# ==================================================
#  CONFIGURACION DE LA BASE DE DATOS (DataSource)
# ==================================================
# En Render, se usarán las variables de entorno spring.datasource.*.
# Para desarrollo local, usará los valores por defecto que apuntan a Docker.
spring.datasource.url=${spring.datasource.url:jdbc:postgresql://localhost:5432/cita_salud_local}
spring.datasource.username=${spring.datasource.username:postgres}
spring.datasource.password=${spring.datasource.password:N2M2XB7EwxWgJoU6qkKQhYtCtt3SmqRN}

# ==================================================
#  CONFIGURACION DE JPA / HIBERNATE
# ==================================================
# En Render, querremos que solo actualice. Localmente, 'create-drop' es útil.
# Puedes manejar esto con perfiles o una variable de entorno.
# Por ahora, dejaremos 'update' que es seguro para ambos.
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# ==================================================
#  CONFIGURACION DE SEGURIDAD (JWT)
# ==================================================
app.jwt-secret=${JWT_SECRET:jkivU98HKkQUzbQq2vjCz+HyKNtkqAsyuyfVr4KF6W/DIEHj9NBx44+PUeuvc3kRY6Yjk84U8IURFgHSl+UuLg==}
app.jwt-expiration-milliseconds=${JWT_EXPIRATION:86400000}

# ==================================================
#  CONFIGURACION DE ACTUATOR Y DOCUMENTACION API
# ==================================================
management.endpoints.web.exposure.include=*
springdoc.api-docs.path=/api-docs

# Nota: Hemos quitado spring.sql.init.mode=always y usamos ddl-auto=update.
# Esto evita que `import.sql` se ejecute en cada reinicio en producción.
# La primera vez que despliegues, la BD de Render estará vacía.
# `update` creará las tablas. Luego tendrás que insertar los datos manualmente
# a través de un cliente de DB o crear un endpoint de "seed" protegido.